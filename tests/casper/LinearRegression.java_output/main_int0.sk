/******************************************************************************/
/* Include necessory packages                                                 */

include "output/utils.sk";
include "output/LinearRegression.sk";
include "output/Point.sk";
include "output/output0.sk";
include "output/kvpair_list_int0.sk";


/******************************************************************************/
/* Global Control Variables                                                   */
int mapKeyType = ??(1);

// Input variables decl
bit loop0;

/******************************************************************************/
/* Main function to verify the two results generated are equal                */

harness void main(int[12] intSet){
	// Initialize output variables.
	int SX_ll0 = 0;
	int SX_ll = intSet[11];
	int SXX_ll0 = 0;
	int SXX_ll = intSet[10];
	int SY_ll0 = 0;
	int SY_ll = intSet[9];
	int SYY_ll0 = 0;
	int SYY_ll = intSet[8];
	int SXY_ll0 = 0;
	int SXY_ll = intSet[7];

	// Initialize input data and variables
    Point[3] points;
	points[0] = new Point();
	points[0].x = intSet[6];
	points[0].y = intSet[5];
	points[1] = new Point();
	points[1].x = intSet[4];
	points[1].y = intSet[3];
	points[2] = new Point();
	points[2].x = intSet[2];
	points[2].y = intSet[1];
	
    // Initialize input broadcast variables
    loop0 = false;
	
    // Initialize loop counters
    int i0 = 0;
	int i = intSet[0];

	// Verification code
	assert loopInvariant(points,0,0,0,0,0,0,0,0,0,0,0,0);
	if(loopInvariant(points,SX_ll,0,SXX_ll,0,SY_ll,0,SYY_ll,0,SXY_ll,0,i,0) && (i<3)) {
		int ind_SX_ll = SX_ll;
		ind_SX_ll = (SX_ll+points[i].x);
		int ind_SY_ll = SY_ll;
		ind_SY_ll = (SY_ll+points[i].y);
		int ind_i = i;
		ind_i = (i+1);
		int ind_SYY_ll = SYY_ll;
		ind_SYY_ll = (SYY_ll+(points[i].y*points[i].y));
		int ind_SXX_ll = SXX_ll;
		ind_SXX_ll = (SXX_ll+(points[i].x*points[i].x));
		int ind_SXY_ll = SXY_ll;
		ind_SXY_ll = (SXY_ll+(points[i].x*points[i].y));
		assert loopInvariant(points,ind_SX_ll,0,ind_SXX_ll,0,ind_SY_ll,0,ind_SYY_ll,0,ind_SXY_ll,0,ind_i,0);
	}
	if(loopInvariant(points,SX_ll,0,SXX_ll,0,SY_ll,0,SYY_ll,0,SXY_ll,0,i,0) && !(i<3)) {
		assert postCondition(points,SX_ll,0,SXX_ll,0,SY_ll,0,SYY_ll,0,SXY_ll,0,i,0);
	}
}

/******************************************************************************/
/* Verification functions                                                     */

bit postCondition(Point[3] points, int SX_ll, int SX_ll0, int SXX_ll, int SXX_ll0, int SY_ll, int SY_ll0, int SYY_ll, int SYY_ll0, int SXY_ll, int SXY_ll0, int i, int i0){
	Output resMR = collect(reduce(map(points,i0,i)), SX_ll0, SXX_ll0, SY_ll0, SYY_ll0, SXY_ll0);
	return resMR.SX_ll == SX_ll && resMR.SXX_ll == SXX_ll && resMR.SY_ll == SY_ll && resMR.SYY_ll == SYY_ll && resMR.SXY_ll == SXY_ll;
}

bit loopInvariant(Point[3] points, int SX_ll, int SX_ll0, int SXX_ll, int SXX_ll0, int SY_ll, int SY_ll0, int SYY_ll, int SYY_ll0, int SXY_ll, int SXY_ll0, int i, int i0){
	Output resMR = collect(reduce(map(points,i0,i)), SX_ll0, SXX_ll0, SY_ll0, SYY_ll0, SXY_ll0);
	return resMR.SX_ll == SX_ll && resMR.SXX_ll == SXX_ll && resMR.SY_ll == SY_ll && resMR.SYY_ll == SYY_ll && resMR.SXY_ll == SXY_ll && 0 <= i && i <= 3;
}

/******************************************************************************/
/* MapReduce Implementation                                                   */

generator int intMapGenerator(Point[3] points, int i){
	int _terminal1 = {| ?? | i | points[i].x | points[i].y |};
	int _terminal2 = {| ?? | i | points[i].x | points[i].y |};
	int _option0 = _terminal1;
	int _option1 = _terminal1 * _terminal2;
	int _option2 = _terminal1 + _terminal2;
	return {| _option0 | _option1 | _option2 |};
}

generator int stringMapGenerator(Point[3] points, int i){
	int _terminal1 = {| -1 |};
	int _terminal2 = {| -1 |};
	int _option0 = _terminal1;
	return {| _option0 |};
}

generator bit bitMapGenerator(Point[3] points, int i){
	bit _terminal1 = {| true | false |};
	bit _terminal2 = {| true | false |};
	bit _option0 = _terminal1;
	return {| _option0 |};
}

List do_map(Point[3] points, int i){
	List result = new List();

	if(mapKeyType == 0){
		Pair kvp = new Pair();
		kvp.intkey = intMapGenerator(points, i);
		kvp.value = intMapGenerator(points, i);
		intlist_put(result, kvp);
	}
	else if(mapKeyType == 1){
		Pair kvp = new Pair();
		kvp.stringkey = stringMapGenerator(points, i);
		kvp.value = intMapGenerator(points, i);
		stringlist_put(result, kvp);
	}
	if(mapKeyType == 0){
		Pair kvp = new Pair();
		kvp.intkey = intMapGenerator(points, i);
		kvp.value = intMapGenerator(points, i);
		intlist_put(result, kvp);
	}
	else if(mapKeyType == 1){
		Pair kvp = new Pair();
		kvp.stringkey = stringMapGenerator(points, i);
		kvp.value = intMapGenerator(points, i);
		stringlist_put(result, kvp);
	}
	if(mapKeyType == 0){
		Pair kvp = new Pair();
		kvp.intkey = intMapGenerator(points, i);
		kvp.value = intMapGenerator(points, i);
		intlist_put(result, kvp);
	}
	else if(mapKeyType == 1){
		Pair kvp = new Pair();
		kvp.stringkey = stringMapGenerator(points, i);
		kvp.value = intMapGenerator(points, i);
		stringlist_put(result, kvp);
	}
	if(mapKeyType == 0){
		Pair kvp = new Pair();
		kvp.intkey = intMapGenerator(points, i);
		kvp.value = intMapGenerator(points, i);
		intlist_put(result, kvp);
	}
	else if(mapKeyType == 1){
		Pair kvp = new Pair();
		kvp.stringkey = stringMapGenerator(points, i);
		kvp.value = intMapGenerator(points, i);
		stringlist_put(result, kvp);
	}
	if(mapKeyType == 0){
		Pair kvp = new Pair();
		kvp.intkey = intMapGenerator(points, i);
		kvp.value = intMapGenerator(points, i);
		intlist_put(result, kvp);
	}
	else if(mapKeyType == 1){
		Pair kvp = new Pair();
		kvp.stringkey = stringMapGenerator(points, i);
		kvp.value = intMapGenerator(points, i);
		stringlist_put(result, kvp);
	}
	

	return result;
}

generator int intReduceGenerator(int val1, int val2){
	int terminal1 = {| val1 | val2 |};
	int terminal2 = {| val1 | val2 |};
	int _option0 = terminal2 * terminal1;
	int _option1 = terminal2 + terminal1;
	return {| _option0 | _option1 |};
}

Pair do_reduce(ListNode values){
	Pair p = new Pair();

	if(values == null)
		return p;

	if(mapKeyType == 0){
		p.intkey = values.intkey;
		p.intkey2 = values.intkey2;
	}
	else if(mapKeyType == 1){
		p.intkey = values.intkey;
		p.stringkey = values.stringkey;
	}

	p.value = {| 0 | 1 |};
	while(values != null){
		p.value = intReduceGenerator(p.value, values.value);
		values = values.next;
	}

	return p;
}

// Calls do_map on each index of the collection
// Equivelant to flatmap() in functional programming
List map(Point[3] points, int i0, int i){
	List result = new List(handle = null);
	
	int _i = i0;
	
	while((_i<i) && (_i<3)){
		
		List kvPairs = do_map(points, _i);
		
		if(mapKeyType == 0){
			intlist_merge(result, kvPairs);
		}
		else if(mapKeyType == 1){
			stringlist_merge(result, kvPairs);
		}

		_i = (_i+1);
	
	}
	return result;
}

// Groups kvPairs by key and calls do_reduce for each key-values pair
// Equivelant to reduce() in functional programming
List reduce(List kvPairs){
	List result = new List(handle = null);
	
	// If map did not emit anything, we are done.
	if(kvPairs.handle == null) return result;

	// Create value arrays by grouping on keys and run reduce function for 
	// each key
	ListNode ptr_st = kvPairs.handle;
	ListNode ptr_end = kvPairs.handle;

	while(ptr_end.next != null){
		if( (mapKeyType == 0 && ptr_end.next.intkey == ptr_st.intkey && ptr_end.next.intkey2 == ptr_st.intkey2) 		||
		    (mapKeyType == 1 && ptr_end.next.intkey == ptr_st.intkey && ptr_end.next.stringkey == ptr_st.stringkey) )
		{
			ptr_end = ptr_end.next;
		}
		else{
			// break chain
			ListNode ptr_temp = ptr_end.next;
			ptr_end.next = null;

			// Run for this key
			Pair kv = do_reduce(ptr_st);
			if(mapKeyType == 0){
				intlist_insert(result,kv);
			}
			else if(mapKeyType == 1){
				stringlist_insert(result,kv);
			}
			
			// Reset for next key
			ptr_st = ptr_temp;
			ptr_end = ptr_temp;
		}
	}

	// Run for last key
	Pair kv = do_reduce(ptr_st);
	if(mapKeyType == 0){
		intlist_insert(result,kv);
	}
	else if(mapKeyType == 1){
		stringlist_insert(result,kv);
	}

	return result;
}

Output collect(List resMR, int SX_ll0, int SXX_ll0, int SY_ll0, int SYY_ll0, int SXY_ll0){
	Output output = new Output();

	if(mapKeyType == 0){
		output.SX_ll = int_get(resMR,0,SX_ll0);
		output.SXX_ll = int_get(resMR,1,SXX_ll0);
		output.SY_ll = int_get(resMR,2,SY_ll0);
		output.SYY_ll = int_get(resMR,3,SYY_ll0);
		output.SXY_ll = int_get(resMR,4,SXY_ll0);
	}
	else if(mapKeyType == 1){
		output.SX_ll = string_get(resMR,0,SX_ll0);
		output.SXX_ll = string_get(resMR,1,SXX_ll0);
		output.SY_ll = string_get(resMR,2,SY_ll0);
		output.SYY_ll = string_get(resMR,3,SYY_ll0);
		output.SXY_ll = string_get(resMR,4,SXY_ll0);
	}

	return output;
}