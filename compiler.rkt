#lang rosette

(require serval/llvm
         serval/lib/core)

(require rosette/lib/angelic
         rosette/lib/synthax
         (rename-in rosette/lib/match (match rosette-match)))

; import the translated benchmarks
(require "tests/basic/benchmarks.ll.rkt")
(require "tests/basic/target.ll.rkt")

; the target language's constructs are encoded as racket structs
; hence rosette's output will also be structs that can be
; decoded easily
; see this for details: https://www.cs.utexas.edu/~bornholt/post/building-synthesizer.html
;
; these structs will be automatically generated when the target language file is parsed
(struct _addOne (args) #:transparent) ; args is of length 1
(struct _ite (args) #:transparent)

; naive algo that recurse up to max depth
(define (gen1 depth vars)
  (cond
    [(<= depth 0)
     (apply choose* vars)]
    [else
     (choose*
      (gen1 0 vars) ; bail out
      (_addOne (list (gen1 (- depth 1) vars))))]))

; same but uses more language constructs (and also int literals)
(define (gen2 depth vars)
  (cond
    [(<= depth 0)
     (apply choose* (append vars (list (?? i32))))] ; (?? i32) means a 32-bit int "hole"

    [else
     (choose*
      (gen2 0 vars)
      (_ite (list (gen2 0 vars) (gen2 0 vars) (gen2 (- depth 1) vars) (gen2 (- depth 1) vars)))
      ; same as above but w/o restricting that the conditional must be comparing variables (and numbers)
      ; this can run for a while!
      ;(_ite (for/list ([i '(1 2 3 4)]) (gen2 (- depth 1) vars)))
      (_addOne (list (gen2 (- depth 1) vars)))
      )]))

; decode the synthesis output in back into C constructs
(define (codegen e)
  (match e
    [(_addOne args)         (apply format "addOne(~a)" (map codegen args))]
    [(_ite args)           (apply format "(~a > ~a) ? (~a) : (~a)" (map codegen args))]
    [(bv val type)         val]
    [(constant name type)  (syntax->datum name)]
    [_                     e]))

; interpret our AST. This simply means calling the "@_" functions
; generated by serval as it parses the input LLVM bytecode.
; this interpreter should also be generated automatically
(define (interpret e)
  (rosette-match e
    [(_addOne arg)  (apply @_addOne (map interpret arg))]
    [(_ite args)    (apply @_ite (map interpret args))]
    [_ e]))

; test harness
(define (run-test spec sym-vars space-gen)
  ; search space grammar. right now hardwire to max depth of 3
  (define E (space-gen 3 sym-vars))  
  (define sol
    (synthesize #:forall sym-vars
                #:guarantee (assert (bveq (apply spec sym-vars) (interpret E)))))
  (displayln (format "solution: ~a" (codegen (evaluate E sol)))))


; main
(parameterize ([current-machine (make-machine)])

  ; define sym vars for program inputs
  (define-symbolic v1 v2 v3 i32)

  ; solution: addOne(addOne(v1))
  (run-test @simple (list v1) gen1)
  ; solution: (42 > 42) ? (addOne((v1 > v3) ? (v2) : (42))) : ((v1 > 42) ? (v2) : (v3))
  (run-test @ite (list v1 v2 v3) gen2)
  ; solution: (v1 > 42) ? (addOne(addOne(v2))) : (addOne((v2 > v2) ? (42) : (v3)))
  (run-test @combined (list v1 v2 v3) gen2)
  )









;  (define E1 (gen1 3 (list v1)))  
;  (define sol1
;    (synthesize #:forall v1
;                #:guarantee (assert (bveq (@simple v1) (interpret E1)))))
;  (displayln (format "sol 1: ~a" (codegen (evaluate E1 sol1))))
;
;
;  (define E2 (gen2 3 (list v1 v2 v3)))  
;  (define sol2
;    (synthesize #:forall (list v1 v2 v3)
;                #:guarantee (assert (bveq (@ite v1 v2 v3) (interpret E2)))))
;  (displayln (format "sol 2: ~a" (codegen (evaluate E2 sol2))))

  ;(define E3 (gen2 3 (list v1 v2 v3)))  
  ;(define sol3
  ;  (synthesize #:forall (list v1 v2 v3)
  ;              #:guarantee (assert (bveq (@combined v1 v2 v3) (interpret E3)))))
  ;(displayln (format "sol 3: ~a" (codegen (evaluate E3 sol3))))

(define-synthax (expr-grammar x depth)
  #:base (choose x (?? (bitvector 32)))
  ;#:base (apply choose x)
  #:else (choose (expr-grammar x 0) (@_addOne (expr-grammar x (- depth 1)))))

(define (gen-expr x)
  (expr-grammar x 5))

;(struct Call (args eval) #:transparent)
;(define (add arg)
;  (Call arg @_addOne))


  ;(print-forms
  ;  (synthesize #:forall i
  ;              #:guarantee (assert (bveq (@simple i) (gen-expr (list i (?? (bitvector 32))))))))



; parse llvm to racket
;
;(define (translate fname)
;  (define c (open-input-file fname))
;  (define m (bytes->module (port->bytes c)))
;
;  (define out (open-output-file #:exists 'replace (string-append fname ".rkt")))
;  (print-module m out)
;  (flush-output out)
;  (close-output-port out))
;  
;
;(translate "benchmarks.ll")
;(translate "target.ll")
;
;; load 
;(dynamic-require "benchmarks.ll.rkt" #f)
;(dynamic-require "target.ll.rkt" '@_addOne)