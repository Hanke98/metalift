#lang rosette

(require serval/llvm
         serval/lib/core)

(require rosette/lib/angelic
         rosette/lib/synthax
         (rename-in rosette/lib/match (match rosette-match)))

; import the translated benchmarks
(require "tests/basic/benchmarks.ll.rkt")
(require "tests/basic/target.ll.rkt")

; the target language's constructs are encoded as racket structs
; hence rosette's output will also be structs that can be
; decoded easily
; see this for details: https://www.cs.utexas.edu/~bornholt/post/building-synthesizer.html
;
; these structs will be automatically generated when the target language file is parsed
(struct _addOne (args) #:transparent) ; args is of length 1
(struct _ite (args) #:transparent)

; naive algo that recurse up to max depth
(define (gen1 depth vars)
  (cond
    [(<= depth 0)
     (apply choose* vars)]
    [else
     (choose*
      (gen1 0 vars) ; bail out
      (_addOne (list (gen1 (- depth 1) vars))))]))

; same but uses more language constructs (and also int literals)
(define (gen2 depth vars)
  (cond
    [(<= depth 0)
     (apply choose* (append vars (list (?? i32))))] ; (?? i32) means a 32-bit int "hole"

    [else
     (choose*
      (gen2 0 vars)
      (_ite (list (gen2 0 vars) (gen2 0 vars) (gen2 (- depth 1) vars) (gen2 (- depth 1) vars)))
      ; same as above but w/o restricting that the conditional must be comparing variables (and numbers)
      ; this can run for a while!
      ;(_ite (for/list ([i '(1 2 3 4)]) (gen2 (- depth 1) vars)))
      (_addOne (list (gen2 (- depth 1) vars)))
      )]))

; decode the synthesis output in back into C constructs
(define (codegen e)
  (match e
    [(_addOne args)         (apply format "addOne(~a)" (map codegen args))]
    [(_ite args)           (apply format "(~a > ~a) ? (~a) : (~a)" (map codegen args))]
    [(bv val type)         val]
    [(constant name type)  (syntax->datum name)]
    [_                     e]))

; interpret our AST. This simply means calling the "@_" functions
; generated by serval as it parses the input LLVM bytecode.
; this interpreter should also be generated automatically
(define (interpret e)
  (rosette-match e
    [(_addOne arg)  (apply @_addOne (map interpret arg))]
    [(_ite args)    (apply @_ite (map interpret args))]
    [_ e]))

; test harness
(define (run-test spec sym-vars space-gen)
  ; search space grammar. right now hardwire to max depth of 3
  (define E (space-gen 3 sym-vars))  
  (define sol
    (synthesize #:forall sym-vars
                #:guarantee (assert (bveq (apply spec sym-vars) (interpret E)))))
  (displayln (format "solution: ~a" (codegen (evaluate E sol)))))


; main
(parameterize ([current-machine (make-machine)])

  ; define sym vars for program inputs
  (define-symbolic v1 v2 v3 i32)

  ; solution: addOne(addOne(v1))
  (run-test @simple (list v1) gen1)
  ; solution: (42 > 42) ? (addOne((v1 > v3) ? (v2) : (42))) : ((v1 > 42) ? (v2) : (v3))
  (run-test @ite (list v1 v2 v3) gen2)
  ; solution: (v1 > 42) ? (addOne(addOne(v2))) : (addOne((v2 > v2) ? (42) : (v3)))
  (run-test @combined (list v1 v2 v3) gen2)
  )
